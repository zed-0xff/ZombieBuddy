plugins {
    id 'java'
    id 'signing'
}

// Game classpath - list of JARs or directories provided via command line (-PgameClasspath=path1,path2,path3)
// Optional: only needed for compilation, not for running tests
def gameClasspathParam = project.findProperty('gameClasspath')
def GAME_CLASSPATH = []

if (gameClasspathParam) {
    // Split by comma and convert to file objects
    GAME_CLASSPATH = gameClasspathParam.split(',').collect { path ->
        file(path.trim())
    }
}

// Read version from VERSION file
def versionFile = file('VERSION')
def version = versionFile.exists() ? versionFile.text.trim() : '1.0.0'

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    implementation 'net.bytebuddy:byte-buddy:1.18.4'
    implementation 'net.bytebuddy:byte-buddy-agent:1.18.4'
    implementation 'io.github.classgraph:classgraph:4.8.184'

    // Only add game classpath if provided (needed for compilation, not for running tests)
    if (!GAME_CLASSPATH.isEmpty()) {
        compileOnly files(GAME_CLASSPATH)
    }
    
    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.0'
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
}

jar {
    archiveBaseName.set("ZombieBuddy")
    manifest {
        attributes(
            'Premain-Class': 'me.zed_0xff.zombie_buddy.Agent',
            'Can-Redefine-Classes': 'true',
            'Can-Retransform-Classes': 'true',
            'Implementation-Version': version
        )
    }
    
    // Create fat JAR - include all dependencies
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    // Exclude META-INF files from dependencies to avoid conflicts
    // Keep our own META-INF/MANIFEST.MF
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    exclude 'META-INF/*.MF'
    exclude 'META-INF/versions/**'
    exclude '*.dll'
    exclude '*.dlz'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Configure signing
// Supports:
// 1. KeychainStore - Direct access to Apple Keychain (no export needed)
// 2. PKCS12 (.p12) - Exported from Keychain
// 3. JKS - Traditional Java keystore
//
// To use KeychainStore (recommended on macOS):
//   - Set signing.storeType=KeychainStore
//   - Set signing.keyAlias to your certificate's common name
//   - Find certificate name: security find-identity -p codesigning -v
//   - No storeFile or passwords needed
def useKeychain = project.findProperty('signing.storeType') == 'KeychainStore'
def hasStoreFile = project.hasProperty('signing.storeFile')

if (useKeychain) {
    // Use KeychainStore - create a custom signing task
    def keyAlias = project.findProperty('signing.keyAlias')
    
    // Create a custom task that uses jarsigner with KeychainStore
    task signJar(type: Exec) {
        dependsOn jar
        onlyIf { keyAlias != null }
        
        def jarFile = jar.archiveFile.get().asFile
        
        // Use jarsigner from PATH or find it from JAVA_HOME
        def jarsignerPath = System.getenv('JAVA_HOME') ? 
            new File(System.getenv('JAVA_HOME'), "bin/jarsigner").absolutePath : 
            "jarsigner"
        
        commandLine jarsignerPath,
            '-keystore', 'NONE',
            '-storetype', 'KeychainStore',
            '-storepass', '',
            '-keypass', '',
            jarFile.absolutePath,
            keyAlias
    }
    
    // Make the build depend on signing
    build.dependsOn signJar
} else if (hasStoreFile) {
    // Use file-based keystore (JKS or PKCS12)
    signing {
        required = true
        
        def storeFilePath = project.findProperty('signing.storeFile')
        def storeFileObj = file(storeFilePath)
        def storeType = project.findProperty('signing.storeType')
        
        // Auto-detect keystore type if not specified
        if (storeType == null) {
            def fileName = storeFileObj.name.toLowerCase()
            if (fileName.endsWith('.p12') || fileName.endsWith('.pfx')) {
                storeType = 'PKCS12'
            } else if (fileName.endsWith('.jks')) {
                storeType = 'JKS'
            }
        }
        
        storeFile = storeFileObj
        storePassword = project.findProperty('signing.storePassword')
        keyAlias = project.findProperty('signing.keyAlias')
        keyPassword = project.findProperty('signing.keyPassword')
        
        sign jar
    }
}

// place all .java files in the 'src' directory
sourceSets {
    main {
        java {
            srcDirs = ['src']
            include '**/*.java'
        }
    }
    test {
        java {
            srcDirs = ['test']
            include '**/*.java'
        }
        // Ensure test source set can access main source set classes
        compileClasspath += main.output
        runtimeClasspath += main.output
    }
    testVanilla {
        java {
            srcDirs = ['test_vanilla']
            include '**/*.java'
        }
        // Ensure testVanilla source set can access main source set classes
        compileClasspath += main.output
        runtimeClasspath += main.output
    }
    testPatched {
        java {
            srcDirs = ['test_patched']
            include '**/*.java'
        }
        // Ensure testPatched source set can access main source set classes
        compileClasspath += main.output
        runtimeClasspath += main.output
    }
    testjar {
        java {
            srcDirs = ['testjar/src']
            include '**/*.java'
        }
        // testjar needs access to main classes for @Patch annotation
        compileClasspath += main.output
    }
    testpatches {
        java {
            srcDirs = ['testpatches']
            include '**/*.java'
        }
        // testpatches needs access to main classes for @Patch annotation
        compileClasspath += main.output
        // testpatches needs access to testjar classes for CustomObject
        compileClasspath += testjar.output
    }
}

// Copy native DLL to build/libs
task copyNativeDll(type: Copy) {
    description = 'Copies zbNative.dll to build/libs directory'
    group = 'build'
    
    def sourceFile = file('../../c/client/windows/zbNative.dll')
    
    doFirst {
        if (!sourceFile.exists()) {
            throw new RuntimeException("zbNative.dll not found at ${sourceFile.absolutePath}")
        }
        println "[ZB] Copying zbNative.dll from ${sourceFile.absolutePath} to ${buildDir}/libs"
    }
    
    from sourceFile
    into "$buildDir/libs"
    
    // Ensure task always runs
    outputs.upToDateWhen { false }
}

tasks.named("check") {
    dependsOn test
}

tasks.named("build") {
    dependsOn check
    finalizedBy copyNativeDll
}

// Ensure copyNativeDll runs after jar is built
copyNativeDll.mustRunAfter jar

// disable annotation processing, JNI headers, and incremental compilation
tasks.withType(JavaCompile).configureEach {
    options.annotationProcessorPath = files()
    options.generatedSourceOutputDirectory.set(provider { null })
    options.headerOutputDirectory.set(provider { null })
    options.incremental = false

    doLast {
        delete "${buildDir}/tmp"
    }
}

// Helper to recursively check for .class files
def hasClassFiles(File dir) {
    if (!dir.exists() || !dir.isDirectory()) {
        return false
    }
    def files = dir.listFiles()
    if (files == null) {
        return false
    }
    for (def file : files) {
        if (file.isFile() && file.name.endsWith('.class')) {
            return true
        }
        if (file.isDirectory() && hasClassFiles(file)) {
            return true
        }
    }
    return false
}

// Require gameClasspath for main source compilation, unless classes are already compiled
def compileJavaTask = tasks.named('compileJava', JavaCompile).get()
compileJavaTask.onlyIf {
    if (!GAME_CLASSPATH.isEmpty()) {
        return true // Always compile if gameClasspath is provided
    }
    
    // Check if classes already exist - recursively search for .class files
    def outputDir = compileJavaTask.destinationDirectory.get().asFile
    if (hasClassFiles(outputDir)) {
        return false // Skip compilation if classes exist
    }
    
    // No classes found - will fail in doFirst
    return true
}

compileJavaTask.doFirst {
    if (GAME_CLASSPATH.isEmpty()) {
        // Verify classes exist (in case onlyIf didn't work)
        def outputDir = destinationDirectory.get().asFile
        if (!hasClassFiles(outputDir)) {
            throw new RuntimeException(
                "gameClasspath must be provided for compilation via -PgameClasspath=<path1>,<path2>,... " +
                "(comma-separated list of JARs or directories).\n" +
                "Example: gradle build -PgameClasspath=../../../../../42.13/java/projectzomboid.jar\n" +
                "Note: Tests can run without gameClasspath if classes are already compiled."
            )
        }
    }
}

// Create JAR for testjar source set (only TargetClass, no patches)
task testJar(type: Jar) {
    archiveBaseName.set("testjar")
    from sourceSets.testjar.output
    // Exclude patch classes - only include TargetClass
    exclude 'testjar/TargetPatch.class'
    dependsOn compileTestjarJava
}

// Create JAR for testpatches source set (contains patch classes)
task testpatchesJar(type: Jar) {
    archiveBaseName.set("testpatches")
    from sourceSets.testpatches.output
    dependsOn compileTestpatchesJava
}

// Add testjar JAR as test dependency
dependencies {
    testImplementation files(tasks.named('testJar'))
    testVanillaImplementation files(tasks.named('testJar'))
    testPatchedImplementation files(tasks.named('testJar'))
    
    // Test dependencies for vanilla and patched tests
    testVanillaImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testVanillaRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.0'
    testPatchedImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testPatchedRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.0'
}

// Configure all test tasks to always run and output test results
tasks.withType(Test) {
    // Always run tests, even if build is up-to-date
    outputs.upToDateWhen { false }
    
    // Don't capture stdout/stderr - show it directly in console
    testLogging {
        showStandardStreams = true
    }
    
    // Disable HTML reports
    reports {
        html.required = false
    }
    
    // Output test results summary
    afterSuite { desc, result ->
        if (!desc.parent) {
            println "\n[=] ${name}: ${result.testCount} tests, ${result.successfulTestCount} successful, ${result.failedTestCount} failed"
        }
    }
}

// Vanilla tests - run without javaagent
// Run with: gradle test_vanilla
task test_vanilla(type: Test) {
    description = 'Runs vanilla tests (without javaagent) from test_vanilla directory'
    group = 'verification'
    
    useJUnitPlatform()
    dependsOn testJar
    
    // Use testVanilla source set
    testClassesDirs = sourceSets.testVanilla.output.classesDirs
    classpath = sourceSets.testVanilla.runtimeClasspath
}

// Patched tests - run with javaagent
// Run with: gradle test_patched
task test_patched(type: Test) {
    description = 'Runs patched tests (with javaagent) from test_patched directory'
    group = 'verification'
    
    useJUnitPlatform()
    dependsOn testJar
    dependsOn testpatchesJar
    dependsOn jar  // Ensure ZombieBuddy.jar is built before tests
    
    // Use testPatched source set
    testClassesDirs = sourceSets.testPatched.output.classesDirs
    classpath = sourceSets.testPatched.runtimeClasspath
    
    // Add javaagent JVM argument with patches_jar parameter
    // Format: <path>:<package_name>
    def patchesJarPath = testpatchesJar.archiveFile.get().asFile.absolutePath
    def patchesPackageName = "me.zed_0xff.zombie_buddy.testpatches"
    jvmArgs = [
        "-javaagent:${jar.archiveFile.get().asFile.absolutePath}=patches_jar=${patchesJarPath}:${patchesPackageName},verbosity=2"
    ]
}

// Unit tests (test/ source set) - e.g. AccessorTest, VersionCheckTest, PatchTest
task unitTest(type: Test) {
    description = 'Runs unit tests from test/ directory'
    group = 'verification'
    useJUnitPlatform()
    dependsOn testJar
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
}

// Main test task - runs unit tests, vanilla, and patched tests
// Run with: gradle test
tasks.named('test', Test) {
    description = 'Runs unit, vanilla, and patched tests'
    group = 'verification'
    
    // Don't discover tests from the default test source set
    testClassesDirs = files()
    classpath = files()
    
    dependsOn unitTest
    dependsOn test_vanilla
    dependsOn test_patched
    
    // Don't fail if no tests are discovered (since we're not running any here)
    failOnNoDiscoveredTests = false
    
    // Force the task to always execute by making it produce output
    outputs.file("${buildDir}/.test-completed")
    
    doLast {
        // Create a marker file to indicate tests completed
        file("${buildDir}/.test-completed").createNewFile()
    }
}
