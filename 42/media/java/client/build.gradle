plugins {
    id 'java'
    id 'signing'
}

// Detect OS and set game paths accordingly
def osName = System.getProperty("os.name").toLowerCase()
def HOME_DIR = System.getProperty("user.home")
def GAME_DIR
def GAME_JAR

if (osName.contains("mac")) {
    // macOS
    GAME_DIR = "${HOME_DIR}/Library/Application Support/Steam/steamapps/common/ProjectZomboid/Project Zomboid.app"
    GAME_JAR = "${GAME_DIR}/Contents/Java/projectzomboid.jar"
} else if (osName.contains("win")) {
    // Windows - try common Steam installation paths
    def programFiles = System.getenv("ProgramFiles(x86)") ?: System.getenv("ProgramFiles")
    def steamPath = System.getenv("SteamPath") ?: "${programFiles}\\Steam"
    GAME_DIR = "${steamPath}\\steamapps\\common\\ProjectZomboid"
    GAME_JAR = "${GAME_DIR}\\projectzomboid.jar"
} else {
    // Linux
    GAME_DIR = "${HOME_DIR}/.steam/steam/steamapps/common/ProjectZomboid"
    GAME_JAR = "${GAME_DIR}/projectzomboid.jar"
}

// Read version from VERSION file
def versionFile = file('VERSION')
def version = versionFile.exists() ? versionFile.text.trim() : '1.0.0'

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    implementation 'net.bytebuddy:byte-buddy:1.18.2'
    implementation 'net.bytebuddy:byte-buddy-agent:1.18.2'
    implementation 'io.github.classgraph:classgraph:4.8.184'

    compileOnly files(GAME_JAR) // only for compilation, not runtime
    
    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.0'
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
}

jar {
    archiveBaseName.set("ZombieBuddy")
    manifest {
        attributes(
            'Premain-Class': 'me.zed_0xff.zombie_buddy.Agent',
            'Can-Redefine-Classes': 'true',
            'Can-Retransform-Classes': 'true',
            'Implementation-Version': version
        )
    }
    
    // Create fat JAR - include all dependencies
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    // Exclude META-INF files from dependencies to avoid conflicts
    // Keep our own META-INF/MANIFEST.MF
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    exclude 'META-INF/*.MF'
    exclude 'META-INF/versions/**'
    exclude '*.dll'
    exclude '*.dlz'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Configure signing
// Supports:
// 1. KeychainStore - Direct access to Apple Keychain (no export needed)
// 2. PKCS12 (.p12) - Exported from Keychain
// 3. JKS - Traditional Java keystore
//
// To use KeychainStore (recommended on macOS):
//   - Set signing.storeType=KeychainStore
//   - Set signing.keyAlias to your certificate's common name
//   - Find certificate name: security find-identity -p codesigning -v
//   - No storeFile or passwords needed
def useKeychain = project.findProperty('signing.storeType') == 'KeychainStore'
def hasStoreFile = project.hasProperty('signing.storeFile')

if (useKeychain) {
    // Use KeychainStore - create a custom signing task
    def keyAlias = project.findProperty('signing.keyAlias')
    
    // Create a custom task that uses jarsigner with KeychainStore
    task signJar(type: Exec) {
        dependsOn jar
        onlyIf { keyAlias != null }
        
        def jarFile = jar.archiveFile.get().asFile
        
        // Use jarsigner from PATH or find it from JAVA_HOME
        def jarsignerExe = osName.contains("win") ? "jarsigner.exe" : "jarsigner"
        def jarsignerPath = System.getenv('JAVA_HOME') ? 
            new File(System.getenv('JAVA_HOME'), "bin/${jarsignerExe}").absolutePath : 
            jarsignerExe
        
        commandLine jarsignerPath,
            '-keystore', 'NONE',
            '-storetype', 'KeychainStore',
            '-storepass', '',
            '-keypass', '',
            jarFile.absolutePath,
            keyAlias
    }
    
    // Make the build depend on signing
    build.dependsOn signJar
} else if (hasStoreFile) {
    // Use file-based keystore (JKS or PKCS12)
    signing {
        required = true
        
        def storeFilePath = project.findProperty('signing.storeFile')
        def storeFileObj = file(storeFilePath)
        def storeType = project.findProperty('signing.storeType')
        
        // Auto-detect keystore type if not specified
        if (storeType == null) {
            def fileName = storeFileObj.name.toLowerCase()
            if (fileName.endsWith('.p12') || fileName.endsWith('.pfx')) {
                storeType = 'PKCS12'
            } else if (fileName.endsWith('.jks')) {
                storeType = 'JKS'
            }
        }
        
        storeFile = storeFileObj
        storePassword = project.findProperty('signing.storePassword')
        keyAlias = project.findProperty('signing.keyAlias')
        keyPassword = project.findProperty('signing.keyPassword')
        
        sign jar
    }
}

// place all .java files in the 'src' directory
sourceSets {
    main {
        java {
            srcDirs = ['src']
            include '**/*.java'
        }
    }
    test {
        java {
            srcDirs = ['test']
            include '**/*.java'
        }
        // Ensure test source set can access main source set classes
        compileClasspath += main.output
        runtimeClasspath += main.output
    }
    testVanilla {
        java {
            srcDirs = ['test_vanilla']
            include '**/*.java'
        }
        // Ensure testVanilla source set can access main source set classes
        compileClasspath += main.output
        runtimeClasspath += main.output
    }
    testPatched {
        java {
            srcDirs = ['test_patched']
            include '**/*.java'
        }
        // Ensure testPatched source set can access main source set classes
        compileClasspath += main.output
        runtimeClasspath += main.output
    }
    testjar {
        java {
            srcDirs = ['testjar/src']
            include '**/*.java'
        }
        // testjar needs access to main classes for @Patch annotation
        compileClasspath += main.output
    }
    testpatches {
        java {
            srcDirs = ['testpatches']
            include '**/*.java'
        }
        // testpatches needs access to main classes for @Patch annotation
        compileClasspath += main.output
        // testpatches needs access to testjar classes for CustomObject
        compileClasspath += testjar.output
    }
}

// Copy native DLL to build/libs
task copyNativeDll(type: Copy) {
    description = 'Copies zbNative.dlz to build/libs directory'
    
    def sourceFile = file('../../c/client/windows/zbNative.dlz')
    
    doFirst {
        if (!sourceFile.exists()) {
            throw new RuntimeException("zbNative.dlz not found at ${sourceFile.absolutePath}")
        }
        println "[ZB] Copying zbNative.dlz from ${sourceFile.absolutePath} to ${buildDir}/libs"
    }
    
    from sourceFile
    into "$buildDir/libs"
}

tasks.named("build") {
    finalizedBy("copyNativeDll")
}

// disable annotation processing, JNI headers, and incremental compilation
tasks.withType(JavaCompile).configureEach {
    options.annotationProcessorPath = files()
    options.generatedSourceOutputDirectory.set(provider { null })
    options.headerOutputDirectory.set(provider { null })
    options.incremental = false

    doLast {
        delete "${buildDir}/tmp"
    }
}

// Create JAR for testjar source set (only TargetClass, no patches)
task testJar(type: Jar) {
    archiveBaseName.set("testjar")
    from sourceSets.testjar.output
    // Exclude patch classes - only include TargetClass
    exclude 'testjar/TargetPatch.class'
    dependsOn compileTestjarJava
}

// Create JAR for testpatches source set (contains patch classes)
task testpatchesJar(type: Jar) {
    archiveBaseName.set("testpatches")
    from sourceSets.testpatches.output
    dependsOn compileTestpatchesJava
}

// Add testjar JAR as test dependency
dependencies {
    testImplementation files(tasks.named('testJar'))
    testVanillaImplementation files(tasks.named('testJar'))
    testPatchedImplementation files(tasks.named('testJar'))
    
    // Test dependencies for vanilla and patched tests
    testVanillaImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testVanillaRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.0'
    testPatchedImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testPatchedRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.0'
}

// Vanilla tests - run without javaagent
// Run with: gradle test_vanilla
task test_vanilla(type: Test) {
    description = 'Runs vanilla tests (without javaagent) from test_vanilla directory'
    group = 'verification'
    
    useJUnitPlatform()
    dependsOn testJar
    
    // Use testVanilla source set
    testClassesDirs = sourceSets.testVanilla.output.classesDirs
    classpath = sourceSets.testVanilla.runtimeClasspath
}

// Patched tests - run with javaagent
// Run with: gradle test_patched
task test_patched(type: Test) {
    description = 'Runs patched tests (with javaagent) from test_patched directory'
    group = 'verification'
    
    useJUnitPlatform()
    dependsOn testJar
    dependsOn testpatchesJar
    dependsOn jar  // Ensure ZombieBuddy.jar is built before tests
    
    // Use testPatched source set
    testClassesDirs = sourceSets.testPatched.output.classesDirs
    classpath = sourceSets.testPatched.runtimeClasspath
    
    // Add javaagent JVM argument with patches_jar parameter
    def patchesJarPath = testpatchesJar.archiveFile.get().asFile.absolutePath
    jvmArgs = [
        "-javaagent:${jar.archiveFile.get().asFile.absolutePath}=patches_jar=${patchesJarPath},verbosity=1"
    ]
}

// Main test task - runs both vanilla and patched tests
// Run with: gradle test
test {
    description = 'Runs both vanilla and patched tests'
    // Don't discover tests from the default test source set
    testClassesDirs = files()
    classpath = files()
    // Just depend on the actual test tasks
    dependsOn test_vanilla
    dependsOn test_patched
    // Don't fail if no tests are discovered (since we're not running any here)
    failOnNoDiscoveredTests = false
}
